# The missing migration guide to the Gradle Kotlin DSL

In case you didn't know, Gradle build scripts can be written in Kotlin rather than Groovy.
However, as far as I know, the Kotlin DSL has never been properly documented.
The closest to a documentation is the set of https://github.com/gradle/kotlin-dsl/tree/master/samples[examples in the kotlin-dsl project]

This README hopefully constitutes the temporary missing guide to migrate from the Groovy DSL to the Kotlin DSL.

It assumes you already know the Groovy DSL, and that you're familiar with the Kotlin language syntax.

## File names

To use the Kotlin DSL, simply name your files `build.gradle.kts` instead of `build.gradle`.

The `settings.gradle` file can also be renamed `settings.gradle.kts`.

In a multi-project build, you can have some modules using the Groovy DSL (and thus use `build.gradle` files), and some other modules using the Kotlin DSL (and thus use `build.gradle.kts` files). So you're not forced to migrate everything at once.

## Applying built-in plugins

Using the `plugins` block:

.Groovy
[source, groovy]
----
plugins {
    id('java')
    id('jacoco')
}
----

.Kotlin
[source, kotlin]
----
plugins {
    java
    id("jacoco")
}
----

As you can see with the `jacoco` example, the same syntax can be used in Groovy and Kotlin (except for double quotes that must be used for Strings in Kotlin, of course).

But the Kotlin DSL also defines extension properties for all (AFAIK) built-in plugins, so you can use them, as shown above with the `java` example.

You can also use the older `apply` syntax:

.Groovy
[source, groovy]
----
apply plugin: 'checkstyle'
----

.Kotlin
[source, kotlin]
----
plugins.apply("checkstyle")
----

## Applying external plugins

Using the `plugins` block:

.Groovy
[source, groovy]
----
plugins {
    id 'org.flywaydb.flyway' version '5.0.3'
}
----

.Kotlin
[source, kotlin]
----
plugins {
    id("org.flywaydb.flyway") version "5.0.3"
}
----

You can also use the older `apply` syntax, but then the plugin must be added to the classpath of the build script:

.Groovy
[source, groovy]
----
buildscript {
    dependencies {
        classpath 'org.springframework.boot:spring-boot-gradle-plugin:2.0.1.RELEASE'
    }
}

repositories {
    mavenCentral()
}

apply plugin: 'io.spring.dependency-management'
----

.Kotlin
[source, kotlin]
----
buildscript {
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:2.0.1.RELEASE")
    }
}

repositories {
    mavenCentral()
}

plugins.apply("io.spring.dependency-management")
----

## Customizing an existing task

This is where Groovy and Kotlin start to differ. Since Kotlin is a statically typed language, and since you want to benefit from this static typing by discovering available properties and methods using auto-completion, you need to know and provide the type of the task you want to configure.

Here is how you can configure a single property of the existing `jar` task:

.Groovy
[source, groovy]
----
jar.archiveName = 'foo.jar'
----

.Kotlin
[source, kotlin]
----
val jar: Jar by tasks
jar.archiveName = "foo.jar"
----

Note that specifying the type of the task explicitly is necessary. Otherwise, the script won't compile because the inferred type of `jar` will be `Task`, and the `archiveName` property is specific to the `Jar` task.

You can, however, omit the type if you only need to configure properties or call methods declared in `Task`:

.Groovy
[source, groovy]
----
test.doLast {
    println("test completed")
}
----

.Kotlin
[source, kotlin]
----
val test by tasks
test.doLast { println("test completed") }
----

If you need to configure several properties or call multiple methods on the same task, the standard `apply` Kotlin extension function is handy:

.Groovy
[source, groovy]
----
jar {
    archiveName = 'foo.jar'
    into('META-INF') {
        from('bar')
    }
}
----

.Kotlin
[source, kotlin]
----
val jar: Jar by tasks
jar.apply {
    archiveName = "foo.jar"
    into("META-INF") {
        from("bar")
    }
}
----
